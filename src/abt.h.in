/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil ; -*- */
/*
 * See COPYRIGHT in top-level directory.
 */

#ifndef ABT_H_INCLUDED
#define ABT_H_INCLUDED

/* user include file for ARGOBOTS programs */

/* Keep C++ compilers from getting confused */
#if defined(__cplusplus)
extern "C" {
#endif

/* ABT_VERSION is the version string. ABT_NUMVERSION is the
 * numeric version that can be used in numeric comparisons.
 *
 * ABT_VERSION uses the following format:
 * Version: [MAJ].[MIN].[REV][EXT][EXT_NUMBER]
 * Example: 1.0.7rc1 has
 *          MAJ = 1
 *          MIN = 0
 *          REV = 7
 *          EXT = rc
 *          EXT_NUMBER = 1
 *
 * ABT_NUMVERSION will convert EXT to a format number:
 *          ALPHA (a) = 0
 *          BETA (b)  = 1
 *          RC (rc)   = 2
 *          PATCH (p) = 3
 * Regular releases are treated as patch 0
 *
 * Numeric version will have 1 digit for MAJ, 2 digits for MIN, 2
 * digits for REV, 1 digit for EXT and 2 digits for EXT_NUMBER. So,
 * 1.0.7rc1 will have the numeric version 10007201.
 */
#define ABT_VERSION "@ABT_VERSION@"
#define ABT_NUMVERSION @ABT_NUMVERSION@

#define ABT_RELEASE_TYPE_ALPHA  0
#define ABT_RELEASE_TYPE_BETA   1
#define ABT_RELEASE_TYPE_RC     2
#define ABT_RELEASE_TYPE_PATCH  3

#define ABT_CALC_VERSION(MAJOR, MINOR, REVISION, TYPE, PATCH) \
    (((MAJOR) * 10000000) + ((MINOR) * 100000) + ((REVISION) * 1000) + ((TYPE) * 100) + (PATCH))


/* Error Classes */
#define ABT_SUCCESS             0   /* Successful return code */
#define ABT_ERR_MEM             1   /* Memeory allocation failure */
#define ABT_ERR_INV_STREAM      2   /* Invalid stream */
#define ABT_ERR_INV_SCHEDULER   3   /* Invalid scheduler */
#define ABT_ERR_INV_THREAD      4   /* Invalid thread */
#define ABT_ERR_INV_TASK        5   /* Invalid task */
#define ABT_ERR_INV_MUTEX       6   /* Invalid mutex */
#define ABT_ERR_INV_CONDITION   7   /* Invalid condition */
#define ABT_ERR_INV_UNIT        8   /* Invalid work unit */
#define ABT_ERR_INV_POOL        9   /* Invalid pool */
#define ABT_ERR_STREAM          10  /* Stream-related error */
#define ABT_ERR_SCHEDULER       11  /* Scheduler-related error */
#define ABT_ERR_THREAD          12  /* Thread-related error */
#define ABT_ERR_TASK            13  /* Task-related error */
#define ABT_ERR_MUTEX_LOCKED    14  /* Return value when mutex is locked */
#define ABT_ERR_MUTEX           15  /* Mutex-related error */
#define ABT_ERR_CONDITION       16  /* Condition-related error */
#define ABT_ERR_UNIT            17  /* Work unit-related error */
#define ABT_ERR_POOL            18  /* Pool-related error */
#define ABT_ERR_OTHER           19  /* Other error */


/* Data Types */
typedef void *                ABT_Stream;       /* Execution Stream */
typedef enum ABT_Stream_state ABT_Stream_state; /* ES state */
typedef void *                ABT_Thread;       /* User-level Thread */
typedef enum ABT_Thread_state ABT_Thread_state; /* ULT state */
typedef void *                ABT_Task;         /* Tasklet */
typedef enum ABT_Task_state   ABT_Task_state;   /* Tasklet state */
typedef void *                ABT_Mutex;        /* Mutex */
typedef void *                ABT_Condition;    /* Condition */
typedef void *                ABT_Scheduler;    /* Scheduler */
typedef enum ABT_Unit_type    ABT_Unit_type;    /* Work unit type */
typedef void *                ABT_Unit;         /* A work unit */
typedef void *                ABT_Pool;         /* Pool of work units */


/* Null Objects */
#define ABT_STREAM_NULL     (NULL)
#define ABT_THREAD_NULL     (NULL)
#define ABT_TASK_NULL       (NULL)
#define ABT_MUTEX_NULL      (NULL)
#define ABT_CONDITION_NULL  (NULL)
#define ABT_SCHEDULER_NULL  (NULL)
#define ABT_POOL_NULL       (NULL)
#define ABT_UNIT_NULL       (NULL)


/* Contants */
enum ABT_Stream_state {
    ABT_STREAM_STATE_CREATED,
    ABT_STREAM_STATE_READY,
    ABT_STREAM_STATE_RUNNING,
    ABT_STREAM_STATE_TERMINATED
};

enum ABT_Thread_state {
    ABT_THREAD_STATE_READY,
    ABT_THREAD_STATE_RUNNING,
    ABT_THREAD_STATE_BLOCKED,
    ABT_THREAD_STATE_COMPLETED,
    ABT_THREAD_STATE_TERMINATED
};

enum ABT_Task_state {
    ABT_TASK_STATE_CREATED,
    ABT_TASK_STATE_DELAYED,
    ABT_TASK_STATE_RUNNING,
    ABT_TASK_STATE_COMPLETED,
    ABT_TASK_STATE_TERMINATED
};

enum ABT_Unit_type {
    ABT_UNIT_TYPE_THREAD,
    ABT_UNIT_TYPE_TASK,
    ABT_UNIT_TYPE_OTHER
};


/* Scheduler Functions */
typedef ABT_Unit_type (*ABT_Unit_get_type_fn)(ABT_Unit);
typedef ABT_Thread (*ABT_Unit_get_thread_fn)(ABT_Unit);
typedef ABT_Task (*ABT_Unit_get_task_fn)(ABT_Unit);
typedef ABT_Unit (*ABT_Unit_create_from_thread_fn)(ABT_Thread);
typedef ABT_Unit (*ABT_Unit_create_from_task_fn)(ABT_Task);
typedef void (*ABT_Unit_free_fn)(ABT_Unit *);
typedef size_t (*ABT_Pool_get_size_fn)(ABT_Pool);
typedef void (*ABT_Pool_push_fn)(ABT_Pool, ABT_Unit);
typedef ABT_Unit (*ABT_Pool_pop_fn)(ABT_Pool);
typedef void (*ABT_Pool_remove_fn)(ABT_Pool, ABT_Unit);

typedef struct {
    ABT_Unit_get_type_fn           u_get_type;
    ABT_Unit_get_thread_fn         u_get_thread;
    ABT_Unit_get_task_fn           u_get_task;
    ABT_Unit_create_from_thread_fn u_create_from_thread;
    ABT_Unit_create_from_task_fn   u_create_from_task;
    ABT_Unit_free_fn               u_free;

    ABT_Pool_get_size_fn p_get_size;
    ABT_Pool_push_fn     p_push;
    ABT_Pool_pop_fn      p_pop;
    ABT_Pool_remove_fn   p_remove;
} ABT_Scheduler_funcs;


/* Init & Finalize */
int ABT_Init(int argc, char **argv);
int ABT_Finalize();

/* Execution Stream (ES) */
int ABT_Stream_create(ABT_Scheduler sched, ABT_Stream *newstream);
int ABT_Stream_free(ABT_Stream *stream);
int ABT_Stream_join(ABT_Stream stream);
int ABT_Stream_exit();
int ABT_Stream_cancel(ABT_Stream stream);
int ABT_Stream_self(ABT_Stream *stream);
int ABT_Stream_equal(ABT_Stream stream1, ABT_Stream stream2, int *result);
int ABT_Stream_set_scheduler(ABT_Stream stream, ABT_Scheduler sched);
int ABT_Stream_get_state(ABT_Stream stream, ABT_Stream_state *state);
int ABT_Stream_set_name(ABT_Stream stream, const char *name);
int ABT_Stream_get_name(ABT_Stream stream, char *name, size_t *len);

/* User-level Thread (ULT) */
int ABT_Thread_create(ABT_Stream stream,
                      void (*thread_func)(void *), void *arg,
                      size_t stacksize, ABT_Thread *newthread);
int ABT_Thread_free(ABT_Thread *thread);
int ABT_Thread_join(ABT_Thread thread);
int ABT_Thread_exit();
int ABT_Thread_cancel(ABT_Thread thread);
int ABT_Thread_yield();
int ABT_Thread_yield_to(ABT_Thread thread);
int ABT_Thread_set_callback(ABT_Thread thread,
                            void (*callback_func)(void *arg), void *arg);
int ABT_Thread_self(ABT_Thread *thread);
int ABT_Thread_retain(ABT_Thread thread);
int ABT_Thread_release(ABT_Thread thread);
int ABT_Thread_equal(ABT_Thread thread1, ABT_Thread thread2, int *result);
int ABT_Thread_get_state(ABT_Thread thread, ABT_Thread_state *state);
int ABT_Thread_set_name(ABT_Thread thread, const char *name);
int ABT_Thread_get_name(ABT_Thread thread, char *name, size_t *len);

/* Tasklet */
int ABT_Task_create(ABT_Stream stream,
                    void (*task_func)(void *), void *arg,
                    ABT_Task *newtask);
int ABT_Task_free(ABT_Task *task);
int ABT_Task_cancel(ABT_Task task);
int ABT_Task_retain(ABT_Task task);
int ABT_Task_release(ABT_Task task);
int ABT_Task_equal(ABT_Task task1, ABT_Task task2, int *result);
int ABT_Task_get_state(ABT_Task task, ABT_Task_state *state);
int ABT_Task_set_name(ABT_Task task, const char *name);
int ABT_Task_get_name(ABT_Task task, char *name, size_t *len);

/* Scheduler */
int ABT_Scheduler_create(ABT_Pool pool,
                         const ABT_Scheduler_funcs *funcs,
                         ABT_Scheduler *newsched);
int ABT_Scheduler_free(ABT_Scheduler *sched);

/* Mutex */
int ABT_Mutex_create(ABT_Mutex *newmutex);
int ABT_Mutex_free(ABT_Mutex *mutex);
int ABT_Mutex_lock(ABT_Mutex mutex);
int ABT_Mutex_trylock(ABT_Mutex mutex);
int ABT_Mutex_unlock(ABT_Mutex mutex);

/* Condition */


#if defined(__cplusplus)
}
#endif

#endif /* ABT_H_INCLUDED */
